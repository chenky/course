<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // var声明及变量提升
        // function getValue(condition) {
        //     if (condition) {
        //         var value = "blue";
        //         console.log("condition is "+condition+", in if value is:"+value);                
        //     } else {
        //         // value exists here with a value of undefined
        //         console.log("condition is "+condition+", in else value is:"+value);  
        //     }
        //     console.log("condition is "+condition+", function end:" +　value);            
        //     // value exists here with a value of undefined
        // }
        // function getValue1(condition) {
        //     var value;
        //     if (condition) {
        //         value = "blue";
        //         console.log("condition is "+condition+", in if value is:"+value);                
        //     } else {
        //         // value exists here with a value of undefined
        //         console.log("condition is "+condition+", in else value is:"+value);  
        //     }
        //     console.log("condition is "+condition+", function end:" +　value);            
        //     // value exists here with a value of undefined
        // }
        // getValue(true);
        // getValue1(false);
        // 通过var声明的变量会被升级到当前作用域的顶部

        // 没有声明的变量会被提升到顶层作用域，这也是很多bug到根源，不要这么写，写代码要高内聚低耦合，这种写法太耦合了
        // function testTopScope(){
        //   topValue = "topValue"
        // }
        // testTopScope()
        // console.log(topValue);     

        // 块级声明
        // 作用域被限制在当前块中
        // function getValueInLet(condition) {
        //     if (condition) {
        //         let value = "blue";
        //         console.log("condition is "+condition+", in if value is:"+value);                
        //     } else {
        //         console.log("condition is "+condition+", in else value is:"+value);  
        //     }
        //     // 访问不到
        //     console.log("condition is "+condition+", function end:" +　value);            
        // }
        // getValueInLet(true);


        // 同一作用域中禁止重复声明
        // var count = 30;
        // // 抛异常
        // let count = 40;

        // var count =30;
        // if(true){
        //     // 临时死区，作用域外无法访问
        //     let count = 40;
        //     console.log("inner:" + count);            
        // }
        // console.log("outer:"+ count);
        // const声明，不可重新赋值，但可以修改对象属性值，必须初始化
        // const obj = {
        //     id: "1"
        // };
        // obj.id = "2";
        // console.log(obj);   
        // // // 异常     
        // obj = {};


        // 循环中的块作用域
        // for (var index = 0; index < 10; index++) {
        //     setTimeout(function(){
        //         console.log(index);                
        //     }, 0);            
        // }
        // IIFE: Immediately Invoked Function Expression
        // for (var index = 0; index < 10; index++) {
        //     setTimeout((function (index) {
        //         return function () {
        //             console.log(index);
        //         }
        //     })(index), 0);
        // }
        for (let index = 0; index < 10; index++) {
            setTimeout(function () {
                console.log(index);
            }, 0);
        }        
        

    </script>
</body>

</html>